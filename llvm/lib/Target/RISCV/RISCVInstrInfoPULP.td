


let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_r<bits<7> funct7, bits<3> funct3,
                 RISCVOpcode opcode, string opcodestr>
    : RVInstR<funct7, funct3, opcode, (outs GPR:$rd), (ins GPR:$rs1),
              opcodestr, "$rd, $rs1">,
      Sched<[WriteIALU, ReadIALU]> {
  let rs2 = 0;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rr<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, string opcodestr,
                  RegisterClass ty1 = GPR, RegisterClass ty2 = ty1, RegisterClass resty = ty1>
    : RVInstR<funct7, funct3, opcode, (outs resty:$rd), (ins ty1:$rs1, ty2:$rs2),
              opcodestr, "$rd, $rs1, $rs2">,
      Sched<[WriteIALU, ReadIALU, ReadIALU]>;

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rr_wb<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, string opcodestr,
                     RegisterClass ty1 = GPR, RegisterClass ty2 = ty1, RegisterClass resty = ty1>
    : RVInstR<funct7, funct3, opcode, (outs resty:$rd_wb), (ins resty:$rd, ty1:$rs1, ty2:$rs2),
              opcodestr, "$rd, $rs1, $rs2">,
      Sched<[WriteIALU, ReadIALU, ReadIALU]>{

  let Constraints = "$rd = $rd_wb";
}




let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_ri<bits<7> funct7, bits<3> funct3, string opcodestr>
    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, uimm5:$Is2),
              opcodestr, "$rd, $rs1, $Is2">,
      Sched<[WriteIALU, ReadIALU]> {
  bits<5> Is2;
  let Inst{24-20} = Is2;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rii<bits<2> funct2, bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, uimm5:$Is3, uimm5:$Is2),
              opcodestr, "$rd, $rs1, $Is3, $Is2">,
      Sched<[WriteIALU, ReadIALU]> {
  bits<5> Is3;
  bits<5> Is2;

  let Inst{31-30} = funct2;
  let Inst{29-25} = Is3;
  let Inst{24-20} = Is2;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rii_wb<bits<2> funct2, bits<3> funct3, string opcodestr>
    : RVInstI<funct3, OPC_OP, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, uimm5:$Is3, uimm5:$Is2),
              opcodestr, "$rd, $rs1, $Is3, $Is2">,
      Sched<[WriteIALU, ReadIALU]> {
  bits<5> Is3;
  bits<5> Is2;

  let Inst{31-30} = funct2;
  let Inst{29-25} = Is3;
  let Inst{24-20} = Is2;

  let Constraints = "$rd = $rd_wb";
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rri<bits<2> funct2, bits<3> funct3, RISCVOpcode opcode, string opcodestr>
    : RVInstI<funct3, opcode, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$Is3),
              opcodestr, "$rd, $rs1, $rs2, $Is3">,
      Sched<[WriteIALU, ReadIALU, ReadIALU]> {
  bits<5> rs2;
  bits<5> Is3;

  let Inst{31-30} = funct2;
  let Inst{29-25} = Is3;
  let Inst{24-20} = rs2;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_rri_wb<bits<2> funct2, bits<3> funct3, RISCVOpcode opcode, string opcodestr>
    : RVInstI<funct3, opcode, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$Is3),
              opcodestr, "$rd, $rs1, $rs2, $Is3">,
      Sched<[WriteIALU, ReadIALU, ReadIALU]> {
  bits<5> rs2;
  bits<5> Is3;

  let Inst{31-30} = funct2;
  let Inst{29-25} = Is3;
  let Inst{24-20} = rs2;

  let Constraints = "$rd = $rd_wb";
}


let Predicates = [HasNonStdExtPulp] in {

// Bit manipulation operations
def P_EXTRACT :   Pulp_ALU_rii   <0b11, 0b000, "p.extract">;
def P_EXTRACTU :  Pulp_ALU_rii   <0b11, 0b001, "p.extractu">;
def P_INSERT :    Pulp_ALU_rii_wb<0b11, 0b010, "p.insert">;
def P_BCLR :      Pulp_ALU_rii   <0b11, 0b011, "p.bclr">;
def P_BSET :      Pulp_ALU_rii   <0b11, 0b100, "p.bset">;

def P_EXTRACTR :  Pulp_ALU_rr   <0b1000000, 0b000, OPC_OP, "p.extractr">;
def P_EXTRACTUR : Pulp_ALU_rr   <0b1000000, 0b001, OPC_OP, "p.extractur">;
def P_INSERTR :   Pulp_ALU_rr_wb<0b1000000, 0b010, OPC_OP, "p.insertr">;
def P_BCLRR :     Pulp_ALU_rr   <0b1000000, 0b011, OPC_OP, "p.bclrr">;
def P_BSETR :     Pulp_ALU_rr   <0b1000000, 0b100, OPC_OP, "p.bsetr">;

def P_ROR :       Pulp_ALU_rr<0b0000100, 0b101, OPC_OP, "p.ror">;
def P_FF1 :       Pulp_ALU_r <0b0001000, 0b000, OPC_OP, "p.ff1">;
def P_FL1 :       Pulp_ALU_r <0b0001000, 0b001, OPC_OP, "p.fl1">;
def P_CLB :       Pulp_ALU_r <0b0001000, 0b010, OPC_OP, "p.clb">;
def P_CNT :       Pulp_ALU_r <0b0001000, 0b011, OPC_OP, "p.cnt">;


// General ALU operations
def P_ABS :    Pulp_ALU_r <0b0000010, 0b000, OPC_OP, "p.abs">;
def P_SLET :   Pulp_ALU_rr<0b0000010, 0b010, OPC_OP, "p.slet">;
def P_SLETU :  Pulp_ALU_rr<0b0000010, 0b011, OPC_OP, "p.sletu">;
def P_MIN :    Pulp_ALU_rr<0b0000010, 0b100, OPC_OP, "p.min">;
def P_MINU :   Pulp_ALU_rr<0b0000010, 0b101, OPC_OP, "p.minu">;
def P_MAX :    Pulp_ALU_rr<0b0000010, 0b110, OPC_OP, "p.max">;
def P_MAXU :   Pulp_ALU_rr<0b0000010, 0b111, OPC_OP, "p.maxu">;
def P_EXTHS :  Pulp_ALU_r <0b0001000, 0b100, OPC_OP, "p.exths">;
def P_EXTHZ :  Pulp_ALU_r <0b0001000, 0b101, OPC_OP, "p.exthz">;
def P_EXTBS :  Pulp_ALU_r <0b0001000, 0b110, OPC_OP, "p.extbs">;
def P_EXTBZ :  Pulp_ALU_r <0b0001000, 0b111, OPC_OP, "p.extbz">;

def P_CLIP :   Pulp_ALU_ri<0b0001010, 0b001, "p.clip">;
def P_CLIPU :  Pulp_ALU_ri<0b0001010, 0b010, "p.clipu">;
def P_CLIPR :  Pulp_ALU_rr<0b0001010, 0b101, OPC_OP, "p.clipr">;
def P_CLIPUR : Pulp_ALU_rr<0b0001010, 0b110, OPC_OP, "p.clipur">;

def P_ADDN :    Pulp_ALU_rri<0b00, 0b010, RISCVOpcode<0b1011011>, "p.addn">;
def P_ADDUN :   Pulp_ALU_rri<0b10, 0b010, RISCVOpcode<0b1011011>, "p.addun">;
def P_ADDRN :   Pulp_ALU_rri<0b00, 0b110, RISCVOpcode<0b1011011>, "p.addrn">;
def P_ADDURN :  Pulp_ALU_rri<0b10, 0b110, RISCVOpcode<0b1011011>, "p.addurn">;
def P_SUBN :    Pulp_ALU_rri<0b00, 0b011, RISCVOpcode<0b1011011>, "p.subn">;
def P_SUBUN :   Pulp_ALU_rri<0b10, 0b011, RISCVOpcode<0b1011011>, "p.subun">;
def P_SUBRN :   Pulp_ALU_rri<0b00, 0b111, RISCVOpcode<0b1011011>, "p.subrn">;
def P_SUBURN :  Pulp_ALU_rri<0b10, 0b111, RISCVOpcode<0b1011011>, "p.suburn">;
def P_ADDNR :   Pulp_ALU_rr_wb<0b0100000, 0b010, RISCVOpcode<0b1011011>, "p.addnr">;
def P_ADDUNR :  Pulp_ALU_rr_wb<0b1100000, 0b010, RISCVOpcode<0b1011011>, "p.addunr">;
def P_ADDRNR :  Pulp_ALU_rr_wb<0b0100000, 0b110, RISCVOpcode<0b1011011>, "p.addrnr">;
def P_ADDURNR : Pulp_ALU_rr_wb<0b1100000, 0b110, RISCVOpcode<0b1011011>, "p.addurnr">;
def P_SUBNR :   Pulp_ALU_rr_wb<0b0100000, 0b011, RISCVOpcode<0b1011011>, "p.subnr">;
def P_SUBUNR :  Pulp_ALU_rr_wb<0b1100000, 0b011, RISCVOpcode<0b1011011>, "p.subunr">;
def P_SUBRNR :  Pulp_ALU_rr_wb<0b0100000, 0b111, RISCVOpcode<0b1011011>, "p.subrnr">;
def P_SUBURNR : Pulp_ALU_rr_wb<0b1100000, 0b111, RISCVOpcode<0b1011011>, "p.suburnr">;
}


def simm5 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<5>(Imm);}]> {
  let ParserMatchClass = SImmAsmOperand<5>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeSImmOperand<5>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isInt<5>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_Immediate_Branch<bits<3> funct3, string opcodestr>
      : RVInstB<funct3, OPC_BRANCH, (outs), (ins GPR:$rs1, simm5:$imm5, simm13_lsb0:$imm12),
                opcodestr, "$rs1, $imm5, $imm12">,
        Sched<[WriteJmp, ReadJmp, ReadJmp]> {
  bits<5> imm5;
  let Inst{24-20} = imm5;

  let isBranch = 1;
  let isTerminator = 1;
}

def P_BEQIMM : Pulp_Immediate_Branch<0b010, "p.beqimm">;
def P_BNEIMM : Pulp_Immediate_Branch<0b011, "p.bneimm">;

// MAC Operations
let Predicates = [HasNonStdExtPulp] in {

def P_MAC :      Pulp_ALU_rr_wb<0b0100001, 0b000, OPC_OP, "p.mac">;
def P_MSU :      Pulp_ALU_rr_wb<0b0100001, 0b001, OPC_OP, "p.msu">;

def P_MULS :     Pulp_ALU_rr<0b1000000, 0b000, RISCVOpcode<0b1011011>, "p.muls">;
def P_MULHHS :   Pulp_ALU_rr<0b1100000, 0b000, RISCVOpcode<0b1011011>, "p.mulhhs">;
def P_MULSN :    Pulp_ALU_rri    <0b10, 0b000, RISCVOpcode<0b1011011>, "p.mulsn">;
def P_MULHHSN :  Pulp_ALU_rri    <0b11, 0b000, RISCVOpcode<0b1011011>, "p.mulhhsn">;
def P_MULSRN :   Pulp_ALU_rri    <0b10, 0b100, RISCVOpcode<0b1011011>, "p.mulsrn">;
def P_MULHHSRN : Pulp_ALU_rri    <0b11, 0b100, RISCVOpcode<0b1011011>, "p.mulhhsrn">;
def P_MULU :     Pulp_ALU_rr<0b0000000, 0b000, RISCVOpcode<0b1011011>, "p.mulu">;
def P_MULHHU :   Pulp_ALU_rr<0b0100000, 0b000, RISCVOpcode<0b1011011>, "p.mulhhu">;
def P_MULUN :    Pulp_ALU_rri    <0b00, 0b000, RISCVOpcode<0b1011011>, "p.mulun">;
def P_MULHHUN :  Pulp_ALU_rri    <0b01, 0b000, RISCVOpcode<0b1011011>, "p.mulhhun">;
def P_MULURN :   Pulp_ALU_rri    <0b00, 0b100, RISCVOpcode<0b1011011>, "p.mulurn">;
def P_MULHHURN : Pulp_ALU_rri    <0b01, 0b100, RISCVOpcode<0b1011011>, "p.mulhhurn">;
def P_MACSN :    Pulp_ALU_rri_wb <0b10, 0b001, RISCVOpcode<0b1011011>, "p.macsn">;
def P_MACHHSN :  Pulp_ALU_rri_wb <0b11, 0b001, RISCVOpcode<0b1011011>, "p.machhsn">;
def P_MACSRN :   Pulp_ALU_rri_wb <0b10, 0b101, RISCVOpcode<0b1011011>, "p.macsrn">;
def P_MACHHSRN : Pulp_ALU_rri_wb <0b11, 0b101, RISCVOpcode<0b1011011>, "p.machhsrn">;
def P_MACUN :    Pulp_ALU_rri_wb <0b00, 0b001, RISCVOpcode<0b1011011>, "p.macun">;
def P_MACHHUN :  Pulp_ALU_rri_wb <0b01, 0b001, RISCVOpcode<0b1011011>, "p.machhun">;
def P_MACURN :   Pulp_ALU_rri_wb <0b00, 0b101, RISCVOpcode<0b1011011>, "p.macurn">;
def P_MACHHURN : Pulp_ALU_rri_wb <0b01, 0b101, RISCVOpcode<0b1011011>, "p.machhurn">;
}

def uimm6 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<6>(Imm);}]> {
  let ParserMatchClass = UImmAsmOperand<6>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<6>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<6>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}


let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_vsci<bits<5> funct5, bit F, bits<3> funct3, string opcodestr,
                    RegisterClass vec, Operand sci, RegisterClass res = vec>
    : RVInst<(outs res:$rd), (ins vec:$rs1, sci:$Imm6), opcodestr,
             "$rd, $rs1, $Imm6", [], InstFormatOther>,
      Sched<[WriteIALU, ReadIALU]>  {
  bits<6> Imm6;
  bits<5> rs1;
  bits<5> rd;

  let Inst{31-27} = funct5;
  let Inst{26} = F;
  let Inst{25} = Imm6{0};
  let Inst{24-20} = Imm6{5-1};
  let Inst{19-15} = rs1;
  let Inst{14-12} = funct3;
  let Inst{11-7} = rd;
  let Opcode = 0b1010111;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_vsci_wb<bits<5> funct5, bit F, bits<3> funct3, string opcodestr,
                    RegisterClass vec, Operand sci, RegisterClass res = vec>
    : RVInst<(outs res:$rd_wb), (ins res:$rd, vec:$rs1, sci:$Imm6), opcodestr,
             "$rd, $rs1, $Imm6", [], InstFormatOther>,
      Sched<[WriteIALU, ReadIALU]>  {
  bits<6> Imm6;
  bits<5> rs1;
  bits<5> rd;

  let Constraints = "$rd = $rd_wb";
  let Inst{31-27} = funct5;
  let Inst{26} = F;
  let Inst{25} = Imm6{0};
  let Inst{24-20} = Imm6{5-1};
  let Inst{19-15} = rs1;
  let Inst{14-12} = funct3;
  let Inst{11-7} = rd;
  let Opcode = 0b1010111;
}


let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_vinsert<bits<3> funct3, RegisterClass res, string opcodestr>
    : RVInst<(outs res:$rd_wb), (ins res:$rd, GPR:$rs1, uimm6:$Imm6), opcodestr, "$rd, $rs1, $Imm6", [], InstFormatOther>,
      Sched<[WriteIALU, ReadIALU]>  {
  bits<6> Imm6;
  bits<5> rs1;
  bits<5> rd;

  let Constraints = "$rd = $rd_wb";
  let Inst{31-27} = 0b10110;
  let Inst{26} = 0;
  let Inst{25} = Imm6{0};
  let Inst{24-20} = Imm6{5-1};
  let Inst{19-15} = rs1;
  let Inst{14-12} = funct3;
  let Inst{11-7} = rd;
  let Opcode = 0b1010111;
}

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class Pulp_ALU_vextract<bits<5> funct5, bits<3> funct3, RegisterClass res, string opcodestr>
    : RVInst<(outs GPR:$rd), (ins res:$rs1, uimm6:$Imm6),
             opcodestr, "$rd, $rs1, $Imm6", [], InstFormatOther>,
      Sched<[WriteIALU, ReadIALU]>  {
  bits<6> Imm6;
  bits<5> rs1;
  bits<5> rd;

  let Inst{31-27} = funct5;
  let Inst{26} = 0;
  let Inst{25} = Imm6{0};
  let Inst{24-20} = Imm6{5-1};
  let Inst{19-15} = rs1;
  let Inst{14-12} = funct3;
  let Inst{11-7} = rd;
  let Opcode = 0b1010111;
}



multiclass SC_SCI_H_B<bits<5> funct5, bit F, Operand sci, string opcodestr> {
  def _H     : Pulp_ALU_rr<{funct5, F, 0}, 0b000, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".h", PulpV2>;
  def _SC_H  : Pulp_ALU_rr<{funct5, F, 0}, 0b100, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.h", PulpV2, GPR>;
  def _SCI_H : Pulp_ALU_vsci<funct5, F,    0b110,                         "pv." # opcodestr # ".sci.h", PulpV2, sci>;
  def _B     : Pulp_ALU_rr<{funct5, F, 0}, 0b001, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".b", PulpV4>;
  def _SC_B  : Pulp_ALU_rr<{funct5, F, 0}, 0b101, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.b", PulpV4, GPR>;
  def _SCI_B : Pulp_ALU_vsci<funct5, F,    0b111,                         "pv." # opcodestr # ".sci.b", PulpV4, sci>;
}

multiclass DOTP<bits<5> funct5, bit F, Operand sci, string opcodestr> {
  def _H     : Pulp_ALU_rr<{funct5, F, 0}, 0b000, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".h", PulpV2, PulpV2, GPR>;
  def _SC_H  : Pulp_ALU_rr<{funct5, F, 0}, 0b100, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.h", PulpV2, GPR, GPR>;
  def _SCI_H : Pulp_ALU_vsci<funct5, F,    0b110,                         "pv." # opcodestr # ".sci.h", PulpV2, sci, GPR>;
  def _B     : Pulp_ALU_rr<{funct5, F, 0}, 0b001, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".b", PulpV4, PulpV4, GPR>;
  def _SC_B  : Pulp_ALU_rr<{funct5, F, 0}, 0b101, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.b", PulpV4, GPR, GPR>;
  def _SCI_B : Pulp_ALU_vsci<funct5, F,    0b111,                         "pv." # opcodestr # ".sci.b", PulpV4, sci, GPR>;
}

multiclass SDOTP<bits<5> funct5, bit F, Operand sci, string opcodestr> {
  def _H     : Pulp_ALU_rr_wb<{funct5, F, 0}, 0b000, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".h", PulpV2, PulpV2, GPR>;
  def _SC_H  : Pulp_ALU_rr_wb<{funct5, F, 0}, 0b100, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.h", PulpV2, GPR, GPR>;
  def _SCI_H : Pulp_ALU_vsci_wb<funct5, F,    0b110,                         "pv." # opcodestr # ".sci.h", PulpV2, sci, GPR>;
  def _B     : Pulp_ALU_rr_wb<{funct5, F, 0}, 0b001, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".b", PulpV4, PulpV4, GPR>;
  def _SC_B  : Pulp_ALU_rr_wb<{funct5, F, 0}, 0b101, RISCVOpcode<0b1010111>, "pv." # opcodestr # ".sc.b", PulpV4, GPR, GPR>;
  def _SCI_B : Pulp_ALU_vsci_wb<funct5, F,    0b111,                         "pv." # opcodestr # ".sci.b", PulpV4, sci, GPR>;
}



// Vectorial ALU Operations
let Predicates = [HasNonStdExtPulp] in {

defm PV_ADD  : SC_SCI_H_B<0b00000, 0, simm6, "add">;
defm PV_SUB  : SC_SCI_H_B<0b00001, 0, simm6, "sub">;
defm PV_AVG  : SC_SCI_H_B<0b00010, 0, simm6, "avg">;
defm PV_AVGU : SC_SCI_H_B<0b00011, 0, uimm6, "avgu">;
defm PV_MIN  : SC_SCI_H_B<0b00100, 0, simm6, "min">;
defm PV_MINU : SC_SCI_H_B<0b00101, 0, uimm6, "minu">;
defm PV_MAX  : SC_SCI_H_B<0b00110, 0, simm6, "max">;
defm PV_MAXU : SC_SCI_H_B<0b00111, 0, uimm6, "maxu">;
defm PV_SRL  : SC_SCI_H_B<0b01000, 0, uimm6, "srl">;
defm PV_SRA  : SC_SCI_H_B<0b01001, 0, uimm6, "sra">;
defm PV_SLL  : SC_SCI_H_B<0b01010, 0, uimm6, "sll">;
defm PV_OR   : SC_SCI_H_B<0b01011, 0, simm6, "or">;
defm PV_XOR  : SC_SCI_H_B<0b01100, 0, simm6, "xor">;
defm PV_AND  : SC_SCI_H_B<0b01101, 0, simm6, "and">;

let hasSideEffects = 0, mayStore = 0, mayLoad = 0 in {
  def PV_ABS_H : RVInstR<0b0111000, 0b000, RISCVOpcode<0b1010111>,
                         (outs PulpV2:$rd), (ins PulpV2:$rs1),
                         "pv.abs.h", "$rd, $rs1">, Sched<[WriteIALU, ReadIALU]>{
    let rs2 = 0;
  }

  def PV_ABS_B : RVInstR<0b0111000, 0b001, RISCVOpcode<0b1010111>,
                         (outs PulpV4:$rd), (ins PulpV4:$rs1),
                         "pv.abs.b", "$rd, $rs1">, Sched<[WriteIALU, ReadIALU]>{
    let rs2 = 0;
  }
}

def PV_EXTRACT_H : Pulp_ALU_vextract<0b01111, 0b110, PulpV2, "pv.extract.h">;
def PV_EXTRACT_B : Pulp_ALU_vextract<0b01111, 0b111, PulpV4, "pv.extract.b">;
def PV_EXTRACTU_H : Pulp_ALU_vextract<0b10010, 0b110, PulpV2, "pv.extractu.h">;
def PV_EXTRACTU_B : Pulp_ALU_vextract<0b10010, 0b111, PulpV4, "pv.extractu.b">;
def PV_INSERT_H   : Pulp_ALU_vinsert<0b110, PulpV2, "pv.insert.h">;
def PV_INSERT_B   : Pulp_ALU_vinsert<0b111, PulpV4, "pv.insert.b">;

defm PV_DOTUP   : DOTP<0b10000, 0, uimm6, "dotup">;
defm PV_DOTUSP  : DOTP<0b10001, 0, simm6, "dotusp">;
defm PV_DOTSP   : DOTP<0b10011, 0, simm6, "dotsp">;
defm PV_SDOTUP  : SDOTP<0b10100, 0, uimm6, "sdotup">;
defm PV_SDOTUSP : SDOTP<0b10101, 0, simm6, "sdotusp">;
defm PV_SDOTSP  : SDOTP<0b10111, 0, simm6, "sdotsp">;

def PV_SHUFFLE_H       : Pulp_ALU_rr<0b1100000, 0b000, RISCVOpcode<0b1010111>, "pv.shuffle.h", PulpV2>;
def PV_SHUFFLE_SCI_H   : Pulp_ALU_vsci<0b11000, 0, 0b110, "pv.shuffle.sci.h", PulpV2, uimm6>;
def PV_SHUFFLE_B       : Pulp_ALU_rr<0b1100000, 0b001, RISCVOpcode<0b1010111>, "pv.shuffle.b", PulpV4>;
def PV_SHUFFLEI0_SCI_B : Pulp_ALU_vsci<0b11000, 0, 0b111, "pv.shufflei0.sci.b", PulpV4, uimm6>;
def PV_SHUFFLEI1_SCI_B : Pulp_ALU_vsci<0b11101, 0, 0b111, "pv.shufflei1.sci.b", PulpV4, uimm6>;
def PV_SHUFFLEI2_SCI_B : Pulp_ALU_vsci<0b11110, 0, 0b111, "pv.shufflei2.sci.b", PulpV4, uimm6>;
def PV_SHUFFLEI3_SCI_B : Pulp_ALU_vsci<0b11111, 0, 0b111, "pv.shufflei3.sci.b", PulpV4, uimm6>;

def PV_SHUFFLE2_H : Pulp_ALU_rr_wb<0b1100100, 0b000, RISCVOpcode<0b1010111>, "pv.shuffle2.h", PulpV2>;
def PV_SHUFFLE2_B : Pulp_ALU_rr_wb<0b1100100, 0b001, RISCVOpcode<0b1010111>, "pv.shuffle2.b", PulpV4>;
def PV_PACK_H : Pulp_ALU_rr<0b1101000, 0b000, RISCVOpcode<0b1010111>, "pv.pack.h", GPR, GPR, PulpV2>;
def PV_PACKHI_B : Pulp_ALU_rr_wb<0b1101100, 0b001, RISCVOpcode<0b1010111>, "pv.packhi.b", GPR, GPR, PulpV4>;
def PV_PACKLO_B : Pulp_ALU_rr_wb<0b1110000, 0b001, RISCVOpcode<0b1010111>, "pv.packlo.b", GPR, GPR, PulpV4>;

let isCodeGenOnly = 1 in
def PV_PACKHI_B_nowb : Pulp_ALU_rr<0b1101100, 0b001, RISCVOpcode<0b1010111>, "pv.packhi.b", GPR, GPR, PulpV4>;


// Vectorial comparison operations
defm PV_CMPEQ  : SC_SCI_H_B<0b00000, 1, simm6, "cmpeq">;
defm PV_CMPNE  : SC_SCI_H_B<0b00001, 1, simm6, "cmpne">;
defm PV_CMPGT  : SC_SCI_H_B<0b00010, 1, simm6, "cmpgt">;
defm PV_CMPGE  : SC_SCI_H_B<0b00011, 1, simm6, "cmpge">;
defm PV_CMPLT  : SC_SCI_H_B<0b00100, 1, simm6, "cmplt">;
defm PV_CMPLE  : SC_SCI_H_B<0b00101, 1, simm6, "cmple">;
defm PV_CMPGTU : SC_SCI_H_B<0b00110, 1, uimm6, "cmpgtu">;
defm PV_CMPGEU : SC_SCI_H_B<0b00111, 1, uimm6, "cmpgeu">;
defm PV_CMPLTU : SC_SCI_H_B<0b01000, 1, uimm6, "cmpltu">;
defm PV_CMPLEU : SC_SCI_H_B<0b01001, 1, uimm6, "cmpleu">;

}

let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
multiclass Pulp_Load<bits<7> funct7, bits<3> funct3, string opcodestr> {

  def _ri_PostIncrement
      : RVInstI<funct3, RISCVOpcode<0b0001011>, (outs GPR:$rd, GPR:$rs1_wb),
                (ins GPR:$rs1, simm12:$imm12), opcodestr, "$rd, ${imm12}(${rs1}!)">{
    let Constraints = "$rs1 = $rs1_wb";
  }

  def _rr_PostIncrement
      : RVInstR<funct7, 0b111, RISCVOpcode<0b0001011>, (outs GPR:$rd, GPR:$rs1_wb),
                (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, ${rs2}(${rs1}!)">{
    let Constraints = "$rs1 = $rs1_wb";
  }

  def _rr
      : RVInstR<funct7, 0b111, RISCVOpcode<0b0000011>, (outs GPR:$rd),
                (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, ${rs2}(${rs1})">;
}


let Predicates = [HasNonStdExtPulp] in {
  defm P_LB  : Pulp_Load<0b0000000, 0b000, "p.lb">,  Sched<[WriteLDB, ReadMemBase]>;
  defm P_LBU : Pulp_Load<0b0100000, 0b100, "p.lbu">, Sched<[WriteLDB, ReadMemBase]>;
  defm P_LH  : Pulp_Load<0b0001000, 0b001, "p.lh">,  Sched<[WriteLDH, ReadMemBase]>;
  defm P_LHU : Pulp_Load<0b0101000, 0b101, "p.lhu">, Sched<[WriteLDH, ReadMemBase]>;
  defm P_LW  : Pulp_Load<0b0010000, 0b010, "p.lw">,  Sched<[WriteLDW, ReadMemBase]>;
}


let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
multiclass Pulp_Store<bits<2> funct2, string opcodestr> {

  def _ri_PostIncrement
      : RVInstS<{0, funct2}, RISCVOpcode<0b0101011>, (outs GPR:$rs1_wb),
                (ins GPR:$rs2, GPR:$rs1, simm12:$imm12), opcodestr, "$rs2, ${imm12}(${rs1}!)">{
    let Constraints = "$rs1 = $rs1_wb";
  }

  def _rr_PostIncrement
      : RVInstR<0b0000000, {1, funct2}, RISCVOpcode<0b0101011>, (outs GPR:$rs1_wb),
                (ins GPR:$rs2, GPR:$rs1, GPR:$rd), opcodestr, "$rs2, ${rd}(${rs1}!)">{
    let Constraints = "$rs1 = $rs1_wb";
  }

  def _rr
      : RVInstR<0b0000000, {1, funct2}, RISCVOpcode<0b0100011>, (outs),
                (ins GPR:$rs2, GPR:$rs1, GPR:$rd), opcodestr, "$rs2, ${rd}(${rs1})">;
}

let Predicates = [HasNonStdExtPulp] in {
  defm P_SB : Pulp_Store<0b00, "p.sb">, Sched<[WriteSTB, ReadStoreData, ReadMemBase]>;
  defm P_SH : Pulp_Store<0b01, "p.sh">, Sched<[WriteSTH, ReadStoreData, ReadMemBase]>;
  defm P_SW : Pulp_Store<0b10, "p.sw">, Sched<[WriteSTW, ReadStoreData, ReadMemBase]>;
}

def uimm1 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<1>(Imm);}]> {
  let ParserMatchClass = UImmAsmOperand<1>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<1>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<1>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

def uimm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<12>(Imm);}]> {
  let ParserMatchClass = UImmAsmOperand<12>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<12>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<12>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

def uimm13_lsb0 : Operand<OtherVT>,
                  ImmLeaf<XLenVT, [{return isShiftedUInt<12, 1>(Imm);}]>  {
  let ParserMatchClass = UImmAsmOperand<13, "Lsb0">;
  let EncoderMethod = "getImmOpValueAsr1";
  let DecoderMethod = "decodeUImmOperand<13>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isShiftedInt<12, 1>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

def uimm6_lsb0 : Operand<OtherVT>,
                  ImmLeaf<XLenVT, [{return isShiftedUInt<5, 1>(Imm);}]>  {
  let ParserMatchClass = UImmAsmOperand<6, "Lsb0">;
  let EncoderMethod = "getImmOpValueAsr1";
  let DecoderMethod = "decodeUImmOperand<13>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isShiftedInt<5, 1>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

let Predicates = [HasNonStdExtPulp],
    hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
  def LP_STARTI : RVInstI<0b000, RISCVOpcode<0b1111011>, (outs),
                          (ins uimm1:$L, uimm13_lsb0:$imm12),
                          "lp.starti", "$L, $imm12">, Sched<[WriteCSR]> {
    bit L;

    let rs1 = 0;
    let rd{4-1} = 0;
    let rd{0} = L;
  }

  def LP_ENDI : RVInstI<0b001, RISCVOpcode<0b1111011>, (outs),
                        (ins uimm1:$L, uimm13_lsb0:$imm12),
                        "lp.endi", "$L, $imm12">, Sched<[WriteCSR]> {
    bit L;

    let rs1 = 0;
    let rd{4-1} = 0;
    let rd{0} = L;
  }

  def LP_COUNT : RVInstI<0b010, RISCVOpcode<0b1111011>, (outs),
                         (ins uimm1:$L, GPR:$rs1), "lp.count", "$L, $rs1">,
                         Sched<[WriteCSR]> {
    bit L;

    let imm12 = 0;
    let rd{4-1} = 0;
    let rd{0} = L;
  }

  def LP_COUNTI : RVInstI<0b011, RISCVOpcode<0b1111011>, (outs),
                          (ins uimm1:$L, uimm12:$imm12),
                          "lp.counti", "$L, $imm12">, Sched<[WriteCSR]> {
    bit L;

    let rs1 = 0;
    let rd{4-1} = 0;
    let rd{0} = L;
  }

  def LP_SETUP : RVInstI<0b100, RISCVOpcode<0b1111011>, (outs),
                         (ins uimm1:$L, GPR:$rs1, uimm13_lsb0:$imm12),
                         "lp.setup", "$L, $rs1, $imm12">,
                         Sched<[WriteCSR, WriteCSR, WriteCSR]> {
    bit L;

    let rd{4-1} = 0;
    let rd{0} = L;
  }

  def LP_SETUPI : RVInstI<0b101, RISCVOpcode<0b1111011>, (outs),
                          (ins uimm1:$L, uimm12:$imm12, uimm6_lsb0:$imm5),
                          "lp.setupi", "$L, $imm12, $imm5">,
                          Sched<[WriteCSR, WriteCSR, WriteCSR]> {
    bit L;
    bits<5> imm5;

    let rs1 = imm5;
    let rd{4-1} = 0;
    let rd{0} = L;
  }
}

let Predicates = [HasNonStdExtPulp],
    hasSideEffects = 1, mayLoad = 1, mayStore = 1 in {
  let isBranch = 1, isTerminator = 1, Size = 0 in
  def LoopBranch : Pseudo<(outs), (ins uimm5:$op1, uimm5:$op2, uimm13_lsb0:$rs1), []>;
  let Size = 12 in
  def LoopIterations : Pseudo<(outs), (ins GPR:$rs1), []>;
  let Size = 12 in
  def LoopIterationsImm : Pseudo<(outs), (ins uimm12:$rs1), []>;
}

def : Pat<(brcond (int_loop_decrement (i32 1)), bb:$loopStart),
          (LoopBranch 0, 0, bb:$loopStart)>;

def : Pat<(int_set_loop_iterations GPR:$rs1),
          (LoopIterations GPR:$rs1)>;

def : Pat<(int_set_loop_iterations uimm12:$rs1),
          (LoopIterationsImm uimm12:$rs1)>;

// Pattern Fragments

def powerOf2Minus1      : ImmLeaf<XLenVT, [{ return isPowerOf2_32(Imm+1);   }]>;
def negativePowerOf2    : ImmLeaf<XLenVT, [{ return isPowerOf2_32(-Imm);    }]>;
def powerOf2            : ImmLeaf<XLenVT, [{ return isPowerOf2_32(Imm);     }]>;
def mask                : ImmLeaf<XLenVT, [{ return isMask_32(Imm);         }]>;
def flippedMask         : ImmLeaf<XLenVT, [{ return isMask_32(~Imm);        }]>;
def shiftedMask         : ImmLeaf<XLenVT, [{ return isShiftedMask_32(Imm);  }]>;
def shiftedFlippedMask  : ImmLeaf<XLenVT, [{ return isShiftedMask_32(~Imm); }]>;


def between
    : PatFrags<(ops node:$lowerBound, node:$upperBound, node:$value),
               [(smin (smax node:$value, node:$lowerBound), node:$upperBound),
                (smax (smin node:$value, node:$upperBound), node:$lowerBound)]>;

def betweenu
    : PatFrags<(ops node:$upperBound, node:$value),
               [(umin (umax node:$value, 0), node:$upperBound),
                (umax (umin node:$value, node:$upperBound), 0)]>;


def clip : PatFrag<(ops node:$lowerBound, node:$upperBound, node:$value),
                   (between node:$lowerBound, node:$upperBound, node:$value), [{

  uint32_t bound1 = (uint32_t) N->getOperand(0)->getConstantOperandVal(1);
  uint32_t bound2 = (uint32_t) N->getConstantOperandVal(1);

  return (bound1 == ~bound2);
}]>;

def shiftRound : PatFrag<(ops node:$value, node:$shiftAmount),
                         (sra (add node:$value, powerOf2),
                              node:$shiftAmount), [{
  return (N->getOperand(0)->getConstantOperandVal(1) << 1)
         == (1 << N->getConstantOperandVal(1));
}]>;

def ushiftRound : PatFrag<(ops node:$value, node:$shiftAmount),
                          (srl (add node:$value, powerOf2),
                               node:$shiftAmount), [{
  return (N->getOperand(0)->getConstantOperandVal(1) << 1)
         == (1 << N->getConstantOperandVal(1));
}]>;

def roundBit : PatFrag<(ops node:$shiftAmount),
                       (srl (shl 1, node:$shiftAmount), (i32 1))>;

def extract : PatFrag<(ops node:$value, node:$leftShift, node:$rightShift),
                      (sra (shl node:$value, node:$leftShift),
                           node:$rightShift), [{
  return N->getOperand(0)->getConstantOperandVal(1)
         <= N->getConstantOperandVal(1);
}]>;

def insert : PatFrag<(ops node:$dest, node:$value, node:$mask, node:$shift),
                     (or (and node:$dest, shiftedFlippedMask),
                         (and (shl node:$value, node:$shift), node:$mask)), [{
  SDValue maskedDest = N->getOperand(0);
  SDValue maskedVal = N->getOperand(1);

  if(maskedDest->getOperand(0)->getOpcode() == ISD::SHL){
    maskedDest = N->getOperand(1);
    maskedVal = N->getOperand(0);
  }

  uint32_t destMask = (uint32_t) maskedDest->getConstantOperandVal(1),
           mask     = (uint32_t) maskedVal->getConstantOperandVal(1),
           shift    = (uint32_t) maskedVal->getOperand(0)->getConstantOperandVal(1);
  return (mask == ~destMask) && (countTrailingZeros(mask) == shift);
}]>;

def maskFromRegs : PatFrag<(ops node:$widthMinus1, node:$shift),
                           (shl (add (shl 2, node:$widthMinus1), -1),
                                node:$shift)>;

def shiftedFlippedMask_shiftImmediate : PatFrag<(ops node:$widthMinus1, node:$mask),
                                  (or (shl flippedMask, node:$widthMinus1),
                                           node:$mask), [{
  uint32_t flippedMask = (uint32_t) N->getOperand(0)->getConstantOperandVal(0);
  uint32_t mask = (uint32_t) N->getConstantOperandVal(1);
  return countTrailingZeros(flippedMask) == (countTrailingOnes(mask) + 1);
}]>;

def shiftedMask_shiftImmediate : PatFrag<(ops node:$widthMinus1, node:$flippedMask),
                                         (add (shl imm, node:$widthMinus1),
                                              node:$flippedMask), [{
  uint32_t shiftedBit = (uint32_t) N->getOperand(0)->getConstantOperandVal(0);
  uint32_t flippedMask = (uint32_t) N->getConstantOperandVal(1);
  return (2 << countTrailingZeros(flippedMask)) == shiftedBit;
}]>;











// SDNode transform functions

def trailing1sPlus1 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(
                          countTrailingOnes<uint32_t>(N->getSExtValue()) + 1,
                          SDLoc(N), N->getValueType(0));
}]>;


def 31minus : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(31 - N->getSExtValue(),
                                   SDLoc(N), N->getValueType(0));
}]>;

def extractOffset : SDNodeXForm<sra, [{
  return CurDAG->getTargetConstant(N->getConstantOperandVal(1)
                                   - N->getOperand(0)->getConstantOperandVal(1),
                                   SDLoc(N), N->getValueType(0));
}]>;


def trailing1s : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(
                          countTrailingOnes<uint32_t>(N->getSExtValue()),
                          SDLoc(N), N->getValueType(0));
}]>;

def flippedMaskWidthMinus1 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(31
                          - countLeadingOnes<uint32_t>(N->getSExtValue())
                          - countTrailingOnes<uint32_t>(N->getSExtValue()),
                          SDLoc(N), N->getValueType(0));
}]>;

def trailing0s : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(
                          countTrailingZeros<uint32_t>(N->getSExtValue()),
                          SDLoc(N), N->getValueType(0));
}]>;

def maskWidthMinus1 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(31
                          - countLeadingZeros<uint32_t>(N->getSExtValue())
                          - countTrailingZeros<uint32_t>(N->getSExtValue()),
                          SDLoc(N), N->getValueType(0));
}]>;



let Predicates = [HasNonStdExtPulp] in {
// Patterns for bit manipulation operations

// extract
// widthMinus1 and shift immediates
def : Pat<(extract:$extract GPR:$rs1, uimm5, uimm5:$shiftRight),
          (P_EXTRACT GPR:$rs1, (31minus imm:$shiftRight), (extractOffset $extract))>;

// shift = 0
def : Pat<(sra (shl GPR:$rs1, (sub 31, GPR:$widthMinus1)),
               (sub 31, GPR:$widthMinus1)),
          (P_EXTRACTR GPR:$rs1, (SLLI GPR:$widthMinus1, 5))>;

// shift immediate
def : Pat<(sra (shl GPR:$rs1, (sub uimm5:$_31MinusShift, GPR:$widthMinus1)),
               (sub 31, GPR:$widthMinus1)),
          (P_EXTRACTR GPR:$rs1, (P_INSERT (ADDI X0, (31minus uimm5:$_31MinusShift)), GPR:$widthMinus1, 4, 5))>;

// widthMinus1 immediate
def : Pat<(sra (shl GPR:$rs1, (sub uimm5:$_32MinusWidth, GPR:$shift)),
               uimm5:$_32MinusWidth),
          (P_EXTRACTR GPR:$rs1, (P_INSERT GPR:$shift, (ADDI X0, (31minus uimm5:$_32MinusWidth)), 4, 5))>;

// widthMinus1 = 0
def : Pat<(sra (shl GPR:$rs1, (sub 31, GPR:$shift)), (i32 31)),
          (P_EXTRACTR GPR:$rs1, (ANDI GPR:$shift, 31))>;

// no immediates
def : Pat<(sra (shl GPR:$rs1, (sub (sub 31, GPR:$widthMinus1), GPR:$shift)),
               (sub 31, GPR:$widthMinus1)),
          (P_EXTRACTR GPR:$rs1, (P_INSERT GPR:$shift, GPR:$widthMinus1, 4, 5))>;

// extractu
// widthMinus1 and shift immediates
def : Pat<(and (srl GPR:$rs1, uimm5:$shift), mask:$mask),
          (P_EXTRACTU GPR:$rs1, (maskWidthMinus1 mask:$mask), uimm5:$shift)>;

// shift = 0
def : Pat<(and GPR:$rs1, (add (shl 2, GPR:$widthMinus1), -1)),
          (P_EXTRACTUR GPR:$rs1, (SLLI GPR:$widthMinus1, 5))>;

// no immediates
def : Pat<(and (srl GPR:$rs1, GPR:$shift), (add (shl 2, GPR:$widthMinus1), -1)),
          (P_EXTRACTUR GPR:$rs1, (P_INSERT GPR:$shift, GPR:$widthMinus1, 4, 5))>;

// insert
// widthMinus1 and shift immediates
def : Pat<(insert GPR:$rd, GPR:$rs1, shiftedMask:$mask, uimm5:$shift),
          (P_INSERT GPR:$rd, GPR:$rs1, (maskWidthMinus1 imm:$mask), uimm5:$shift)>;

// widthMinus1 immediate
def : Pat<(or (and GPR:$rd, (not (shl mask:$mask, GPR:$shift))),
              (shl (and GPR:$rs1, mask:$mask), GPR:$shift)),
          (P_INSERTR GPR:$rd, GPR:$rs1,
                     (P_INSERT GPR:$shift,
                               (ADDI X0, (maskWidthMinus1 mask:$mask)), 4, 5))>;

// widthMinus1 = 0
def : Pat<(or (and GPR:$rd, (not (shl 1, GPR:$shift))),
              (shl (and GPR:$rs1, 1), GPR:$shift)),
          (P_INSERTR GPR:$rd, GPR:$rs1, (ANDI GPR:$shift, 31))>;

// shift = 0
def : Pat<(or (and GPR:$rs1, (add (shl 2, GPR:$widthMinus1), -1)),
              (and GPR:$rd, (sub 0, (shl 2, GPR:$widthMinus1)))),
          (P_INSERTR GPR:$rd, GPR:$rs1, (SLLI GPR:$widthMinus1, 5))>;

// no immediates
def : Pat<(or (and GPR:$dest, (not (maskFromRegs GPR:$widthMinus1, GPR:$shift))),
              (shl (and (add (shl 2, GPR:$widthMinus1), -1), GPR:$rs1), GPR:$shift)),
          (P_INSERTR GPR:$dest, GPR:$rs1, (P_INSERT GPR:$shift, GPR:$widthMinus1, 4, 5))>;

// bclr
// widthMinus1 and shift immediates
def : Pat<(and GPR:$rs1, shiftedFlippedMask:$mask),
          (P_BCLR GPR:$rs1, (flippedMaskWidthMinus1 imm:$mask), (trailing1s imm:$mask))>;

// widthMinus1 immediate
def : Pat<(and GPR:$rs1, (not (shl mask:$mask, GPR:$shift))),
          (P_BCLRR GPR:$rs1, (P_INSERT GPR:$shift, (ADDI X0, (maskWidthMinus1 mask:$mask)), 4, 5))>;

// widthMinus1 = 0
def : Pat<(and GPR:$rs1, (not (shl 1, GPR:$shift))),
          (P_BCLRR GPR:$rs1, (ANDI GPR:$shift, 31))>;

// shift immediate
def : Pat<(and GPR:$rs1, (shiftedFlippedMask_shiftImmediate GPR:$widthMinus1, mask:$mask)),
          (P_BCLRR GPR:$rs1, (P_INSERT (ADDI X0, (trailing1s mask:$mask)),
                                       GPR:$widthMinus1, 4, 5))>;

// shift = 0
def : Pat<(and GPR:$rs1, (shl -2, GPR:$widthMinus1)),
          (P_BCLRR GPR:$rs1, (SLLI GPR:$widthMinus1, 5))>;

// no immediates
def : Pat<(and (not (maskFromRegs GPR:$widthMinus1, GPR:$shift)), GPR:$rs1),
          (P_BCLRR GPR:$rs1, (P_INSERT GPR:$shift, GPR:$widthMinus1, 4, 5))>;

// bset
// widthMinus1 and shift immediates
def : Pat<(or GPR:$rs1, shiftedMask:$mask),
          (P_BSET GPR:$rs1, (maskWidthMinus1 imm:$mask), (trailing0s imm:$mask))>;

// widthMinus1 immediate
def : Pat<(or GPR:$rs1, (shl mask:$mask, GPR:$shift)),
          (P_BSETR GPR:$rs1, (P_INSERT GPR:$shift, (ADDI X0, (maskWidthMinus1 mask:$mask)), 4, 5))>;

// widthMinus1 = 0
def : Pat<(or GPR:$rs1, (shl 1, GPR:$shift)),
          (P_BSETR GPR:$rs1, (ANDI GPR:$shift, 31))>;

// shift immediate
def : Pat<(or GPR:$rs1, (shiftedMask_shiftImmediate GPR:$widthMinus1, flippedMask:$flippedMask)),
          (P_BSETR GPR:$rs1, (P_INSERT (ADDI X0, (trailing0s flippedMask:$flippedMask)),
                                       GPR:$widthMinus1, 4, 5))>;

// shift = 0
def : Pat<(or GPR:$rs1, (add (shl 2, GPR:$widthMinus1), -1)),
          (P_BSETR GPR:$rs1, (SLLI GPR:$widthMinus1, 5))>;

// no immediates
def : Pat<(or (maskFromRegs GPR:$widthMinus1, GPR:$shift), GPR:$rs1),
          (P_BSETR GPR:$rs1, (P_INSERT GPR:$shift, GPR:$widthMinus1, 4, 5))>;


def : Pat<(cttz GPR:$rs1), (P_FF1 GPR:$rs1)>;
def : Pat<(ctlz_zero_undef GPR:$rs1), (XORI (P_FL1 GPR:$rs1), 31)>;
def : Pat<(xor (ctlz_zero_undef GPR:$rs1), 31), (P_FL1 GPR:$rs1)>;
def : Pat<(ctlz_zero_undef (xor GPR:$rs1, (sra GPR:$rs1, (i32 31)))), (P_CLB GPR:$rs1)>;
def : Pat<(ctpop GPR:$rs1), (P_CNT GPR:$rs1)>;
def : PatGprGpr<rotr, P_ROR>;


// Patterns for general ALU operations

def : Pat<(abs GPR:$rs1), (P_ABS GPR:$rs1)>;
def : PatGprGpr<setle, P_SLET>;
def : PatGprGpr<setule, P_SLETU>;
def : PatGprGpr<smin, P_MIN>;
def : PatGprGpr<umin, P_MINU>;
def : PatGprGpr<smax, P_MAX>;
def : PatGprGpr<umax, P_MAXU>;

def : Pat<(sext_inreg GPR:$rs1, i16), (P_EXTHS GPR:$rs1)>;
def : Pat<(sext_inreg GPR:$rs1, i8 ), (P_EXTBS GPR:$rs1)>;
def : Pat<(and GPR:$rs1, 0xffff), (P_EXTHZ GPR:$rs1)>;
def : Pat<(and GPR:$rs1, 0xff  ), (P_EXTBZ GPR:$rs1)>;

def : Pat<(clip negativePowerOf2, powerOf2Minus1:$upperBound, GPR:$rs1),
          (P_CLIP GPR:$rs1, (trailing1sPlus1 imm:$upperBound))>;
def : Pat<(between (not GPR:$rs2), GPR:$rs2, GPR:$rs1),
          (P_CLIPR GPR:$rs1, GPR:$rs2)>;
def : Pat<(betweenu powerOf2Minus1:$upperBound, GPR:$rs1),
          (P_CLIPU GPR:$rs1, (trailing1sPlus1 imm:$upperBound))>;
def : Pat<(betweenu GPR:$rs2, GPR:$rs1),
          (P_CLIPUR GPR:$rs1, GPR:$rs2)>;

def : Pat<(sra (add GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_ADDN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(srl (add GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_ADDUN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(shiftRound (add GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_ADDRN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(ushiftRound (add GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_ADDURN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;

def : Pat<(sra (sub GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_SUBN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(srl (sub GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_SUBUN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(shiftRound (sub GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_SUBRN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;
def : Pat<(ushiftRound (sub GPR:$rs1, GPR:$rs2), uimm5:$Is3),
          (P_SUBURN GPR:$rs1, GPR:$rs2, uimm5:$Is3)>;

def : Pat<(sra (add GPR:$rd, GPR:$rs1), GPR:$rs2),
          (P_ADDNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(srl (add GPR:$rd, GPR:$rs1), GPR:$rs2),
          (P_ADDUNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(sra (add (add GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
          (P_ADDRNR  GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(srl (add (add GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
          (P_ADDURNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;

def : Pat<(sra (sub GPR:$rd, GPR:$rs1), GPR:$rs2),
          (P_SUBNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(srl (sub GPR:$rd, GPR:$rs1), GPR:$rs2),
          (P_SUBUNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(sra (add (sub GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
          (P_SUBRNR  GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(srl (add (sub GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
          (P_SUBURNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;

}




// Patterns for vectorial ALU operations
class PatV2V2<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV2:$rs1, PulpV2:$rs2), (Inst PulpV2:$rs1, PulpV2:$rs2)>;

class PatV4V4<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV4:$rs1, PulpV4:$rs2), (Inst PulpV4:$rs1, PulpV4:$rs2)>;

class PatV2GPR<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV2:$rs1, (v2i16 (splat_vector GPR:$rs2))), (Inst PulpV2:$rs1, GPR:$rs2)>;

class PatV4GPR<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV4:$rs1, (v4i8 (splat_vector GPR:$rs2))), (Inst PulpV4:$rs1, GPR:$rs2)>;

class PatV2Simm6<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV2:$rs1, (v2i16 (splat_vector simm6:$imm))), (Inst PulpV2:$rs1, simm6:$imm)>;

class PatV4Simm6<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV4:$rs1, (v4i8 (splat_vector simm6:$imm))), (Inst PulpV4:$rs1, simm6:$imm)>;

class PatV2Uimm6<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV2:$rs1, (v2i16 (splat_vector uimm6:$imm))), (Inst PulpV2:$rs1, uimm6:$imm)>;

class PatV4Uimm6<SDPatternOperator OpNode, RVInst Inst>
    : Pat<(OpNode PulpV4:$rs1, (v4i8 (splat_vector uimm6:$imm))), (Inst PulpV4:$rs1, uimm6:$imm)>;

multiclass GeneralSVectorPattern<SDPatternOperator OpNode, string Inst> {
  def : PatV2V2   <OpNode, !cast<RVInst>("PV_" # Inst # "_H")>;
  def : PatV2GPR  <OpNode, !cast<RVInst>("PV_" # Inst # "_SC_H")>;
  def : PatV2Simm6<OpNode, !cast<RVInst>("PV_" # Inst # "_SCI_H")>;
  def : PatV4V4   <OpNode, !cast<RVInst>("PV_" # Inst # "_B")>;
  def : PatV4GPR  <OpNode, !cast<RVInst>("PV_" # Inst # "_SC_B")>;
  def : PatV4Simm6<OpNode, !cast<RVInst>("PV_" # Inst # "_SCI_B")>;
}

multiclass GeneralUVectorPattern<SDPatternOperator OpNode, string Inst> {
  def : PatV2V2   <OpNode, !cast<RVInst>("PV_" # Inst # "_H")>;
  def : PatV2GPR  <OpNode, !cast<RVInst>("PV_" # Inst # "_SC_H")>;
  def : PatV2Uimm6<OpNode, !cast<RVInst>("PV_" # Inst # "_SCI_H")>;
  def : PatV4V4   <OpNode, !cast<RVInst>("PV_" # Inst # "_B")>;
  def : PatV4GPR  <OpNode, !cast<RVInst>("PV_" # Inst # "_SC_B")>;
  def : PatV4Uimm6<OpNode, !cast<RVInst>("PV_" # Inst # "_SCI_B")>;
}

class vec_avg<ValueType vectype, SDNode shiftOp>
    : PatFrag<(ops node:$rs1, node:$rs2),
              (shiftOp (add node:$rs1, node:$rs2),
                       (vectype (splat_vector (i32 1))))>;


let Predicates = [HasNonStdExtPulp] in {

defm : GeneralSVectorPattern<add, "ADD">;
defm : GeneralSVectorPattern<sub, "SUB">;
defm : GeneralSVectorPattern<smin, "MIN">;
defm : GeneralUVectorPattern<umin, "MINU">;
defm : GeneralSVectorPattern<smax, "MAX">;
defm : GeneralUVectorPattern<umax, "MAXU">;
defm : GeneralUVectorPattern<srl, "SRL">;
defm : GeneralUVectorPattern<sra, "SRA">;
defm : GeneralUVectorPattern<shl, "SLL">;
defm : GeneralSVectorPattern<or, "OR">;
defm : GeneralSVectorPattern<xor, "XOR">;
defm : GeneralSVectorPattern<and, "AND">;

def : PatV2V2<vec_avg<v2i16, sra>, PV_AVG_H>;
def : PatV2GPR<vec_avg<v2i16, sra>, PV_AVG_SC_H>;
def : PatV2Simm6<vec_avg<v2i16, sra>, PV_AVG_SCI_H>;
def : PatV4V4<vec_avg<v4i8, sra>, PV_AVG_B>;
def : PatV4GPR<vec_avg<v4i8, sra>, PV_AVG_SC_B>;
def : PatV4Simm6<vec_avg<v4i8, sra>, PV_AVG_SCI_B>;

def : PatV2V2<vec_avg<v2i16, srl>, PV_AVGU_H>;
def : PatV2GPR<vec_avg<v2i16, srl>, PV_AVGU_SC_H>;
def : PatV2Simm6<vec_avg<v2i16, srl>, PV_AVGU_SCI_H>;
def : PatV4V4<vec_avg<v4i8, srl>, PV_AVGU_B>;
def : PatV4GPR<vec_avg<v4i8, srl>, PV_AVGU_SC_B>;
def : PatV4Simm6<vec_avg<v4i8, srl>, PV_AVGU_SCI_B>;

def : Pat<(abs PulpV2:$rs1), (PV_ABS_H PulpV2:$rs1)>;
def : Pat<(abs PulpV4:$rs1), (PV_ABS_B PulpV4:$rs1)>;


def : Pat<(i32 (vector_extract (v2i16 PulpV2:$rs1), uimm6:$index)),
          (PV_EXTRACT_H PulpV2:$rs1, uimm6:$index)>;
def : Pat<(i32 (vector_extract (v4i8 PulpV4:$rs1), uimm6:$index)),
          (PV_EXTRACT_B PulpV4:$rs1, uimm6:$index)>;
def : Pat<(i32 (sext_inreg (vector_extract PulpV2:$rs1, uimm6:$index), i16)),
          (PV_EXTRACT_H PulpV2:$rs1, uimm6:$index)>;
def : Pat<(i32 (sext_inreg (vector_extract PulpV4:$rs1, uimm6:$index), i8)),
          (PV_EXTRACT_B PulpV4:$rs1, uimm6:$index)>;
def : Pat<(i32 (and (vector_extract (v2i16 PulpV2:$rs1), uimm6:$index), 65535)),
          (PV_EXTRACT_H PulpV2:$rs1, uimm6:$index)>;
def : Pat<(i32 (and (vector_extract (v4i8 PulpV4:$rs1), uimm6:$index), 255)),
          (PV_EXTRACT_B PulpV4:$rs1, uimm6:$index)>;
def : Pat<(vector_insert PulpV2:$rd, GPR:$rs1, uimm6:$index),
          (PV_INSERT_H PulpV2:$rd, GPR:$rs1, uimm6:$index)>;
def : Pat<(vector_insert PulpV4:$rd, GPR:$rs1, uimm6:$index),
          (PV_INSERT_B PulpV4:$rd, GPR:$rs1, uimm6:$index)>;


let isCodeGenOnly = 1 in { // Helper for Patterns
  def P_INSERTR_v2 : Pulp_ALU_rr_wb<0b1000000, 0b010, OPC_OP, "p.insertr", GPR, GPR, PulpV2>;
  def P_INSERTR_v4 : Pulp_ALU_rr_wb<0b1000000, 0b010, OPC_OP, "p.insertr", GPR, GPR, PulpV4>;
  def PV_SHUFFLE_H_GPR : Pulp_ALU_rr<0b1100000, 0b000, RISCVOpcode<0b1010111>, "pv.shuffle.h", PulpV2, GPR, GPR>;
  def PV_SHUFFLE_B_GPR : Pulp_ALU_rr<0b1100000, 0b001, RISCVOpcode<0b1010111>, "pv.shuffle.b", PulpV4, GPR, GPR>;
}

// insert/extract without immediate index

def : Pat<(vector_insert PulpV2:$rd, GPR:$rs1, GPR:$index),
          (P_INSERTR_v2 PulpV2:$rd, GPR:$rs1,
                     (P_INSERT (ADDI X0, 0b111100000), GPR:$index, 0, 4))>;
def : Pat<(vector_insert PulpV4:$rd, GPR:$rs1, GPR:$index),
          (P_INSERTR_v4 PulpV4:$rd, GPR:$rs1,
                     (P_INSERT (ADDI X0, 0b11100000), GPR:$index, 1, 3))>;

def : Pat<(i32 (vector_extract PulpV2:$rs1, GPR:$rs2)),
          (PV_SHUFFLE_H_GPR PulpV2:$rs1, GPR:$rs2)>;
def : Pat<(i32 (vector_extract PulpV4:$rs1, GPR:$rs2)),
          (PV_SHUFFLE_B_GPR PulpV4:$rs1, GPR:$rs2)>;

}

def sbextract : PatFrag<(ops node:$vector, node:$index),
                        (sext_inreg (vector_extract (v4i8 node:$vector), node:$index), i8)>;
def ubextract : PatFrag<(ops node:$vector, node:$index),
                        (and (vector_extract (v4i8 node:$vector), node:$index), 255)>;
def shextract : PatFrag<(ops node:$vector, node:$index),
                        (sext_inreg (vector_extract (v2i16 node:$vector), node:$index), i16)>;
def uhextract : PatFrag<(ops node:$vector, node:$index),
                        (and (vector_extract (v2i16 node:$vector), node:$index), 65535)>;

class dotp_h<PatFrag extractOp1, PatFrag extractOp2>
    : PatFrag<(ops node:$rs1, node:$rs2),
              (add (mul (extractOp1 node:$rs1, 0), (extractOp2 node:$rs2, 0)),
                   (mul (extractOp1 node:$rs1, 1), (extractOp2 node:$rs2, 1)))>;

def dotup_h  : dotp_h<uhextract, uhextract>;
def dotusp_h : dotp_h<uhextract, shextract>;
def dotsp_h  : dotp_h<shextract, shextract>;

class dotp_sc_h<PatFrag extractOp>
    : PatFrag<(ops node:$rs1, node:$sc),
              (mul (add (extractOp node:$rs1, 0), (extractOp node:$rs1, 1)), node:$sc)>;

def dotup_sc_h : dotp_sc_h<uhextract>;
def dotsp_sc_h : dotp_sc_h<shextract>;

// Tablegen only permutes 3 operands, so we have to permute the 4th operand manually
def sum4 : PatFrags<(ops node:$a, node:$b, node:$c, node:$d),
                    [(add (add (add node:$a, node:$b), node:$c), node:$d),
                     (add (add (add node:$a, node:$b), node:$d), node:$c),
                     (add (add (add node:$a, node:$d), node:$c), node:$b),
                     (add (add (add node:$d, node:$b), node:$c), node:$a),
                     (add (add node:$a, node:$b), (add node:$c, node:$d))]>;

class dotp_b<PatFrag extractOp1, PatFrag extractOp2>
    : PatFrag<(ops node:$rs1, node:$rs2),
              (sum4 (mul (extractOp1 node:$rs1, 0), (extractOp2 node:$rs2, 0)),
                    (mul (extractOp1 node:$rs1, 1), (extractOp2 node:$rs2, 1)),
                    (mul (extractOp1 node:$rs1, 2), (extractOp2 node:$rs2, 2)),
                    (mul (extractOp1 node:$rs1, 3), (extractOp2 node:$rs2, 3)))>;

def dotup_b  : dotp_b<ubextract, ubextract>;
def dotusp_b : dotp_b<ubextract, sbextract>;
def dotsp_b  : dotp_b<sbextract, sbextract>;

class dotp_sc_b<PatFrag extractOp>
    : PatFrag<(ops node:$rs1, node:$sc),
              (mul (sum4 (extractOp node:$rs1, 0),
                         (extractOp node:$rs1, 1),
                         (extractOp node:$rs1, 2),
                         (extractOp node:$rs1, 3)), node:$sc)>;

def dotup_sc_b : dotp_sc_b<ubextract>;
def dotsp_sc_b : dotp_sc_b<sbextract>;

let Predicates = [HasNonStdExtPulp] in {

def : PatV2V2<dotup_h, PV_DOTUP_H>;

def : Pat<(dotup_sc_h PulpV2:$rs1, (and GPR:$rs2, 65535)),
          (PV_DOTUP_SC_H PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(dotup_sc_h PulpV2:$rs1, uimm6:$sci),
          (PV_DOTUP_SCI_H PulpV2:$rs1, uimm6:$sci)>;

def : PatV4V4<dotup_b, PV_DOTUP_B>;

def : Pat<(dotup_sc_b PulpV4:$rs1, (and GPR:$rs2, 255)),
          (PV_DOTUP_SC_B PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(dotup_sc_b PulpV4:$rs1, uimm6:$sci),
          (PV_DOTUP_SCI_B PulpV4:$rs1, uimm6:$sci)>;


def : PatV2V2<dotusp_h , PV_DOTUSP_H>;

def : Pat<(dotup_sc_h PulpV2:$rs1, (sext_inreg GPR:$rs2, i16)),
          (PV_DOTUSP_SC_H PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(dotup_sc_h PulpV2:$rs1, simm6:$sci),
          (PV_DOTUSP_SCI_H PulpV2:$rs1, simm6:$sci)>;

def : PatV4V4<dotusp_b, PV_DOTUSP_B>;

def : Pat<(dotup_sc_b PulpV4:$rs1, (sext_inreg GPR:$rs2, i8)),
          (PV_DOTUSP_SC_B PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(dotup_sc_b PulpV4:$rs1, simm6:$sci),
          (PV_DOTUSP_SCI_B PulpV4:$rs1, simm6:$sci)>;


def : PatV2V2<dotsp_h , PV_DOTSP_H>;

def : Pat<(dotsp_sc_h PulpV2:$rs1, (sext_inreg GPR:$rs2, i16)),
          (PV_DOTSP_SC_H PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(dotsp_sc_h PulpV2:$rs1, simm6:$sci),
          (PV_DOTSP_SCI_H PulpV2:$rs1, simm6:$sci)>;

def : PatV4V4<dotsp_b, PV_DOTSP_B>;

def : Pat<(dotsp_sc_b PulpV4:$rs1, (sext_inreg GPR:$rs2, i8)),
          (PV_DOTSP_SC_B PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(dotsp_sc_b PulpV4:$rs1, simm6:$sci),
          (PV_DOTSP_SCI_B PulpV4:$rs1, simm6:$sci)>;





def : Pat<(add GPR:$rd, (dotup_h PulpV2:$rs1, PulpV2:$rs2)),
          (PV_SDOTUP_H GPR:$rd, PulpV2:$rs1, PulpV2:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_h PulpV2:$rs1, (and GPR:$rs2, 65535))),
          (PV_SDOTUP_SC_H GPR:$rd, PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_h PulpV2:$rs1, uimm6:$sci)),
          (PV_SDOTUP_SCI_H GPR:$rd, PulpV2:$rs1, uimm6:$sci)>;

def : Pat<(add GPR:$rd, (dotup_b PulpV4:$rs1, PulpV4:$rs2)),
          (PV_SDOTUP_B GPR:$rd, PulpV4:$rs1, PulpV4:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_b PulpV4:$rs1, (and GPR:$rs2, 255))),
          (PV_SDOTUP_SC_B GPR:$rd, PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_b PulpV4:$rs1, uimm6:$sci)),
          (PV_SDOTUP_SCI_B GPR:$rd, PulpV4:$rs1, uimm6:$sci)>;


def : Pat<(add GPR:$rd, (dotusp_h PulpV2:$rs1, PulpV2:$rs2)),
          (PV_SDOTUSP_H GPR:$rd, PulpV2:$rs1, PulpV2:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_h PulpV2:$rs1, (sext_inreg GPR:$rs2, i16))),
          (PV_SDOTUSP_SC_H GPR:$rd, PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_h PulpV2:$rs1, simm6:$sci)),
          (PV_SDOTUSP_SCI_H GPR:$rd, PulpV2:$rs1, simm6:$sci)>;

def : Pat<(add GPR:$rd, (dotusp_b PulpV4:$rs1, PulpV4:$rs2)),
          (PV_SDOTUSP_B GPR:$rd, PulpV4:$rs1, PulpV4:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_b PulpV4:$rs1, (sext_inreg GPR:$rs2, i8))),
          (PV_SDOTUSP_SC_B GPR:$rd, PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotup_sc_b PulpV4:$rs1, simm6:$sci)),
          (PV_SDOTUSP_SCI_B GPR:$rd, PulpV4:$rs1, simm6:$sci)>;


def : Pat<(add GPR:$rd, (dotsp_h PulpV2:$rs1, PulpV2:$rs2)),
          (PV_SDOTSP_H GPR:$rd, PulpV2:$rs1, PulpV2:$rs2)>;

def : Pat<(add GPR:$rd, (dotsp_sc_h PulpV2:$rs1, (sext_inreg GPR:$rs2, i16))),
          (PV_SDOTSP_SC_H GPR:$rd, PulpV2:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotsp_sc_h PulpV2:$rs1, simm6:$sci)),
          (PV_SDOTSP_SCI_H GPR:$rd, PulpV2:$rs1, simm6:$sci)>;

def : Pat<(add GPR:$rd, (dotsp_b PulpV4:$rs1, PulpV4:$rs2)),
          (PV_SDOTSP_B GPR:$rd, PulpV4:$rs1, PulpV4:$rs2)>;

def : Pat<(add GPR:$rd, (dotsp_sc_b PulpV4:$rs1, (sext_inreg GPR:$rs2, i8))),
          (PV_SDOTSP_SC_B GPR:$rd, PulpV4:$rs1, GPR:$rs2)>;

def : Pat<(add GPR:$rd, (dotsp_sc_b PulpV4:$rs1, simm6:$sci)),
          (PV_SDOTSP_SCI_B GPR:$rd, PulpV4:$rs1, simm6:$sci)>;


// TODO shuffle instructions









def : Pat<(v2i16 (build_vector GPR:$rs1, GPR:$rs2)),
          (PV_PACK_H GPR:$rs2, GPR:$rs1)>;
def : Pat<(v4i8 (build_vector GPR:$rs1, GPR:$rs2, GPR:$rs3, GPR:$rs4)),
          (PV_PACKLO_B (PV_PACKHI_B_nowb GPR:$rs4, GPR:$rs3), GPR:$rs2, GPR:$rs1)>;

def : Pat<(v2i16 (splat_vector GPR:$rs1)), (PV_PACK_H GPR:$rs1, GPR:$rs1)>;
def : Pat<(v4i8 (splat_vector GPR:$rs1)), (PV_ADD_SC_B X0, GPR:$rs1)>;



defm : GeneralSVectorPattern<seteq, "CMPEQ">;
defm : GeneralSVectorPattern<setne, "CMPNE">;
defm : GeneralSVectorPattern<setgt, "CMPGT">;
defm : GeneralSVectorPattern<setge, "CMPGE">;
defm : GeneralSVectorPattern<setlt, "CMPLT">;
defm : GeneralSVectorPattern<setle, "CMPLE">;
defm : GeneralUVectorPattern<setugt, "CMPGTU">;
defm : GeneralUVectorPattern<setuge, "CMPGEU">;
defm : GeneralUVectorPattern<setult, "CMPLTU">;
defm : GeneralUVectorPattern<setule, "CMPLEU">;




def : Pat<(v2i16 (bitconvert GPR:$rs1)), (v2i16 PulpV2:$rs1)>;
def : Pat<(v4i8 (bitconvert GPR:$rs1)), (v4i8 PulpV4:$rs1)>;
def : Pat<(i32 (bitconvert PulpV2:$rs1)), (i32 GPR:$rs1)>;
def : Pat<(i32 (bitconvert PulpV4:$rs1)), (i32 GPR:$rs1)>;


// Patterns for load/store instructions

// post increment loads need custom selection, because tablegen can't deal with
// multiple result values

def : Pat<(sextloadi8 (add GPR:$base, GPR:$offset)),
          (P_LB_rr GPR:$base, GPR:$offset)>;
def : Pat<(zextloadi8 (add GPR:$base, GPR:$offset)),
          (P_LBU_rr GPR:$base, GPR:$offset)>;
def : Pat<(sextloadi16 (add GPR:$base, GPR:$offset)),
          (P_LH_rr GPR:$base, GPR:$offset)>;
def : Pat<(zextloadi16 (add GPR:$base, GPR:$offset)),
          (P_LHU_rr GPR:$base, GPR:$offset)>;
def : Pat<(load (add GPR:$base, GPR:$offset)),
          (P_LW_rr GPR:$base, GPR:$offset)>;

def : Pat<(post_truncsti8 GPR:$val, GPR:$base, simm12:$offset),
          (P_SB_ri_PostIncrement GPR:$val, GPR:$base, simm12:$offset)>;
def : Pat<(post_truncsti16 GPR:$val, GPR:$base, simm12:$offset),
          (P_SH_ri_PostIncrement GPR:$val, GPR:$base, simm12:$offset)>;
def : Pat<(post_store GPR:$val, GPR:$base, simm12:$offset),
          (P_SW_ri_PostIncrement GPR:$val, GPR:$base, simm12:$offset)>;

def : Pat<(post_truncsti8 GPR:$val, GPR:$base, GPR:$offset),
          (P_SB_rr_PostIncrement GPR:$val, GPR:$base, GPR:$offset)>;
def : Pat<(post_truncsti16 GPR:$val, GPR:$base, GPR:$offset),
          (P_SH_rr_PostIncrement GPR:$val, GPR:$base, GPR:$offset)>;
def : Pat<(post_store GPR:$val, GPR:$base, GPR:$offset),
          (P_SW_rr_PostIncrement GPR:$val, GPR:$base, GPR:$offset)>;

def : Pat<(truncstorei8 GPR:$val, (add GPR:$base, GPR:$offset)),
          (P_SB_rr GPR:$val, GPR:$base, GPR:$offset)>;
def : Pat<(truncstorei16 GPR:$val, (add GPR:$base, GPR:$offset)),
          (P_SH_rr GPR:$val, GPR:$base, GPR:$offset)>;
def : Pat<(store GPR:$val, (add GPR:$base, GPR:$offset)),
          (P_SW_rr GPR:$val, GPR:$base, GPR:$offset)>;









// Patterns for builtin functions
class UnaryBuiltin<Intrinsic intrinsic, Instruction instruction>
      : Pat<(intrinsic GPR:$rs1), (instruction GPR:$rs1)>;

def : UnaryBuiltin<int_riscv_pulp_fl1, P_FL1>;
def : UnaryBuiltin<int_riscv_pulp_ff1, P_FF1>;
def : UnaryBuiltin<int_riscv_pulp_clb, P_CLB>;
def : UnaryBuiltin<int_riscv_pulp_cnt, P_CNT>;
def : Pat<(int_riscv_pulp_parity GPR:$rs1), (P_BCLR (P_CNT GPR:$rs1), 30, 1)>;
def : UnaryBuiltin<int_riscv_pulp_abs, P_ABS>;

def : Pat<(int_riscv_pulp_mac GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MAC GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_msu GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MSU GPR:$rd, GPR:$rs1, GPR:$rs2)>;

//def : Pat<(int_riscv_pulp_macs GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MACSN GPR:$rd, GPR:$rs1, GPR:$rs2, 0)>;
//def : Pat<(int_riscv_pulp_macu GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MACUN GPR:$rd, GPR:$rs1, GPR:$rs2, 0)>;

//def : Pat<(int_riscv_pulp_machhs GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MACHHSN GPR:$rd, GPR:$rs1, GPR:$rs2, 0)>;
//def : Pat<(int_riscv_pulp_machhu GPR:$rs1, GPR:$rs2, GPR:$rd), (P_MACHHUN GPR:$rd, GPR:$rs1, GPR:$rs2, 0)>;

def : PatGprGpr<int_riscv_pulp_rotr, P_ROR>;

def : PatGprGpr<int_riscv_pulp_maxsi, P_MAX>;
def : PatGprGpr<int_riscv_pulp_minsi, P_MIN>;
def : PatGprGpr<int_riscv_pulp_maxusi, P_MAXU>;
def : PatGprGpr<int_riscv_pulp_minusi, P_MINU>;

multiclass BinaryVectorBuiltin<string intrin, string instr> {
  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_" # intrin # "2"),
                  !cast<RVInst>("PV_" # instr # "_H")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_" # intrin # "4"),
                  !cast<RVInst>("PV_" # instr # "_B")>;
}

/*defm : BinaryVectorBuiltin<"add",  "ADD">;
defm : BinaryVectorBuiltin<"sub",  "SUB">;
defm : BinaryVectorBuiltin<"avg",  "AVG">;
defm : BinaryVectorBuiltin<"avgu", "AVGU">;
defm : BinaryVectorBuiltin<"min",  "MIN">;
defm : BinaryVectorBuiltin<"minu", "MINU">;
defm : BinaryVectorBuiltin<"max",  "MAX">;
defm : BinaryVectorBuiltin<"maxu", "MAXU">;
defm : BinaryVectorBuiltin<"and",  "AND">;
defm : BinaryVectorBuiltin<"or",   "OR">;
defm : BinaryVectorBuiltin<"exor", "XOR">;
defm : BinaryVectorBuiltin<"srl",  "SRL">;
defm : BinaryVectorBuiltin<"sra",  "SRA">;
defm : BinaryVectorBuiltin<"sll",  "SLL">;
defm : BinaryVectorBuiltin<"abs",  "ABS">;
def : Pat<(int_riscv_pulp_neg2 GPR:$rs1), (PV_SUB_H X0, GPR:$rs1)>;
def : Pat<(int_riscv_pulp_neg4 GPR:$rs1), (PV_SUB_B X0, GPR:$rs1)>;
*/

multiclass DotproductBuiltin<string intrin, string instr> {
  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_dot" # intrin # "p2"),
                  !cast<RVInst>("PV_DOT" # instr # "P_H")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_dot" # intrin # "psc2"),
                  !cast<RVInst>("PV_DOT" # instr # "P_SC_H")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_dot" # intrin # "p4"),
                  !cast<RVInst>("PV_DOT" # instr # "P_B")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_dot" # intrin # "psc4"),
                  !cast<RVInst>("PV_DOT" # instr # "P_SC_B")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_sdot" # intrin # "p2"),
                  !cast<RVInst>("PV_SDOT" # instr # "P_H")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_sdot" # intrin # "psc2"),
                  !cast<RVInst>("PV_SDOT" # instr # "P_SC_H")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_sdot" # intrin # "p4"),
                  !cast<RVInst>("PV_SDOT" # instr # "P_B")>;

  def : PatGprGpr<!cast<Intrinsic>("int_riscv_pulp_sdot" # intrin # "psc4"),
                  !cast<RVInst>("PV_SDOT" # instr # "P_SC_B")>;

}

//defm : DotproductBuiltin<"s",  "S">;
//defm : DotproductBuiltin<"u",  "U">;
//defm : DotproductBuiltin<"us", "US">;

//def : PatGprGpr<int_riscv_pulp_muls, P_MULS>;
//def : PatGprGpr<int_riscv_pulp_mulu, P_MULU>;
def : PatGprGpr<int_riscv_pulp_mulhhs, P_MULHHS>;
def : PatGprGpr<int_riscv_pulp_mulhhu, P_MULHHU>;

multiclass MulMacBuiltin<string intrin, string instr> {

    def : Pat<(!cast<Intrinsic>("int_riscv_pulp_mul" # intrin # "N")
                    GPR:$rs1, GPR:$rs2, uimm5:$shift),
              (!cast<RVInst>("P_MUL" # instr # "N")
                    GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

    def : Pat<(!cast<Intrinsic>("int_riscv_pulp_mul" # intrin # "RN")
                    GPR:$rs1, GPR:$rs2, uimm5:$shift, imm),
              (!cast<RVInst>("P_MUL" # instr # "RN")
                    GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

    def : Pat<(!cast<Intrinsic>("int_riscv_pulp_mac" # intrin # "N")
                    GPR:$rs1, GPR:$rs2, GPR:$rd, uimm5:$shift),
              (!cast<RVInst>("P_MAC" # instr # "N")
                    GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

    def : Pat<(!cast<Intrinsic>("int_riscv_pulp_mac" # intrin # "RN")
                    GPR:$rs1, GPR:$rs2, GPR:$rd, uimm5:$shift, imm),
              (!cast<RVInst>("P_MAC" # instr # "RN")
                    GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

}

//defm : MulMacBuiltin<"s",   "S">;
//defm : MulMacBuiltin<"u",   "U">;
//defm : MulMacBuiltin<"hhs", "HHS">;
//defm : MulMacBuiltin<"hhu", "HHU">;

multiclass add_sub_N_RN_r<string intrin, string instr> {

      def : Pat<(!cast<Intrinsic>("int_riscv_pulp_" # intrin # "N")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift),
                (!cast<RVInst>("P_" # instr # "N")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

      def : Pat<(!cast<Intrinsic>("int_riscv_pulp_" # intrin # "N_r")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift),
                (!cast<RVInst>("P_" # instr # "NR")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

      def : Pat<(!cast<Intrinsic>("int_riscv_pulp_" # intrin # "RN")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift, imm),
                (!cast<RVInst>("P_" # instr # "RN")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

      def : Pat<(!cast<Intrinsic>("int_riscv_pulp_" # intrin # "RN_r")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift),
                (!cast<RVInst>("P_" # instr # "RNR")
                      GPR:$rs1, GPR:$rs2, uimm5:$shift)>;

}

defm : add_sub_N_RN_r<"add",  "ADD">;
defm : add_sub_N_RN_r<"addu", "ADDU">;
defm : add_sub_N_RN_r<"sub",  "SUB">;
defm : add_sub_N_RN_r<"subu", "SUBU">;

/*
def : PatGprGpr<int_riscv_pulp_pack2, PV_PACK_H>;
def : Pat<(set GPR:$rd, (int_riscv_pulp_pack4 GPR:$rs1, GPR:$rs2, GPR:$rs3, GPR:$rs4)),
          (PV_PACKLO_B (PV_PACKHI_B GPR:$rd, GPR:$rs4, GPR:$rs3), GPR:$rs2, GPR:$rs1)>;
def : PatGprGpr<int_riscv_pulp_shuffleh, PV_SHUFFLE_H>;
def : PatGprGpr<int_riscv_pulp_shuffleb, PV_SHUFFLE_B>;
def : Pat<(int_riscv_pulp_pack4_lo GPR:$rd, GPR:$rs2, GPR:$rs1), (PV_PACKLO_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_pack4_hi GPR:$rd, GPR:$rs2, GPR:$rs1), (PV_PACKHI_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_pack4_lo GPR:$rs2, GPR:$rs1, GPR:$rd),
          (PV_PACKLO_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_pack4_hi GPR:$rs2, GPR:$rs1, GPR:$rd),
          (PV_PACKHI_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;
// TODO shuffle4b & shuffle2b
*/

def : Pat<(int_riscv_pulp_bclr GPR:$rs1, shiftedFlippedMask:$mask),
          (P_BCLR GPR:$rs1, (flippedMaskWidthMinus1 imm:$mask), (trailing1s imm:$mask))>;
def : PatGprGpr<int_riscv_pulp_bclr_r, P_BCLRR>;

def : Pat<(int_riscv_pulp_bset GPR:$rs1, shiftedMask:$mask),
          (P_BCLR GPR:$rs1, (maskWidthMinus1 imm:$mask), (trailing0s imm:$mask))>;
def : PatGprGpr<int_riscv_pulp_bset_r, P_BSETR>;

def : Pat<(int_riscv_pulp_bextract GPR:$rs1, uimm5:$size, uimm5:$shift),
          (P_EXTRACT GPR:$rs1, uimm5:$size, uimm5:$shift)>;
def : PatGprGpr<int_riscv_pulp_bextract_r, P_EXTRACTR>;

def : Pat<(int_riscv_pulp_bextractu GPR:$rs1, uimm5:$size, uimm5:$shift),
          (P_EXTRACTU GPR:$rs1, uimm5:$size, uimm5:$shift)>;
def : PatGprGpr<int_riscv_pulp_bextractu_r, P_EXTRACTUR>;

def : Pat<(int_riscv_pulp_binsert GPR:$rd, shiftedFlippedMask,
                                  GPR:$rs1, shiftedMask:$srcMask, uimm5:$shift),
          (P_INSERT GPR:$rd, GPR:$rs1, (maskWidthMinus1 imm:$srcMask), uimm5:$shift)>;
def : Pat<(int_riscv_pulp_binsert_r GPR:$rd, GPR:$rs1, GPR:$rs2),
          (P_INSERTR GPR:$rd, GPR:$rs1, GPR:$rs2)>;

def : Pat<(int_riscv_pulp_clip GPR:$rs1, negativePowerOf2:$lowerBound,
                               powerOf2Minus1),
          (P_CLIP GPR:$rs1, (trailing0s imm:$lowerBound))>;
def : PatGprGpr<int_riscv_pulp_clip_r, P_CLIPR>;

def : Pat<(int_riscv_pulp_clipu GPR:$rs1, 0, powerOf2Minus1:$upperBound),
          (P_CLIPU GPR:$rs1, (trailing1sPlus1 imm:$upperBound))>;
def : PatGprGpr<int_riscv_pulp_clip_r, P_CLIPR>;


def : Pat<(int_riscv_pulp_OffsetedRead GPR:$rs1, GPR:$rs2), (P_LW_rr GPR:$rs1, GPR:$rs2)>;
//def : Pat<(int_riscv_pulp_OffsetedReadHalf GPR:$rs1, GPR:$rs2), (P_LH_rr GPR:$rs1, GPR:$rs2)>;
//def : Pat<(int_riscv_pulp_OffsetedReadByte GPR:$rs1, GPR:$rs2), (P_LB_rr GPR:$rs1, GPR:$rs2)>;

def : Pat<(int_riscv_pulp_OffsetedWrite GPR:$rs2, GPR:$rs1, GPR:$rs3), (P_SW_rr GPR:$rs2, GPR:$rs1, GPR:$rs3)>;
def : Pat<(int_riscv_pulp_OffsetedWriteHalf GPR:$rs2, GPR:$rs1, GPR:$rs3), (P_SH_rr GPR:$rs2, GPR:$rs1, GPR:$rs3)>;
def : Pat<(int_riscv_pulp_OffsetedWriteByte GPR:$rs2, GPR:$rs1, GPR:$rs3), (P_SB_rr GPR:$rs2, GPR:$rs1, GPR:$rs3)>;


def : Pat<(int_riscv_pulp_read_base_off GPR:$rs1, GPR:$rs2), (P_LW_rr GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_write_base_off GPR:$rs2, GPR:$rs1, GPR:$rs3), (P_SW_rr GPR:$rs2, GPR:$rs1, GPR:$rs3)>;

def : Pat<(int_riscv_pulp_spr_read_vol uimm12:$imm12), (CSRRS csr_sysreg:$imm12, X0)>;
def : Pat<(int_riscv_pulp_spr_read uimm12:$imm12), (CSRRS csr_sysreg:$imm12, X0)>;

def : Pat<(int_riscv_pulp_spr_write uimm12:$imm12, GPR:$rs1), (CSRRW csr_sysreg:$imm12, GPR:$rs1)>;
def : Pat<(int_riscv_pulp_spr_bit_set uimm12:$imm12, GPR:$rs1), (CSRRS csr_sysreg:$imm12, GPR:$rs1)>;
def : Pat<(int_riscv_pulp_spr_bit_clr uimm12:$imm12, GPR:$rs1), (CSRRC csr_sysreg:$imm12, GPR:$rs1)>;

def : Pat<(int_riscv_pulp_read_then_spr_write uimm12:$imm12, GPR:$rs1), (CSRRW csr_sysreg:$imm12, GPR:$rs1)>;
def : Pat<(int_riscv_pulp_read_then_spr_bit_set uimm12:$imm12, GPR:$rs1), (CSRRS csr_sysreg:$imm12, GPR:$rs1)>;
def : Pat<(int_riscv_pulp_read_then_spr_bit_clr uimm12:$imm12, GPR:$rs1), (CSRRC csr_sysreg:$imm12, GPR:$rs1)>;

def : Pat<(int_riscv_pulp_read_base_off_v GPR:$rs1, GPR:$rs2), (P_LW_rr GPR:$rs1, GPR:$rs2)>;
def : Pat<(int_riscv_pulp_write_base_off_v GPR:$rs2, GPR:$rs1, GPR:$rs3), (P_SW_rr GPR:$rs2, GPR:$rs3, GPR:$rs1)>;

}
